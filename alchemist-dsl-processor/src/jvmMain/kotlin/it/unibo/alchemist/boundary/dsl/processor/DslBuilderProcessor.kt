package it.unibo.alchemist.boundary.dsl.processor

import com.google.devtools.ksp.getClassDeclarationByName
import com.google.devtools.ksp.getConstructors
import com.google.devtools.ksp.isPublic
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSValueParameter
import com.google.devtools.ksp.validate
import findConstructor
import it.unibo.alchemist.boundary.dsl.AlchemistKotlinDSL
import it.unibo.alchemist.boundary.dsl.processor.data.ConstructorInfo
import it.unibo.alchemist.boundary.dsl.processor.data.GenerationContext
import it.unibo.alchemist.boundary.dsl.processor.data.InjectableConstructor
import it.unibo.alchemist.boundary.dsl.processor.data.InjectionContext
import it.unibo.alchemist.boundary.dsl.processor.data.InjectionType
import it.unibo.alchemist.boundary.dsl.processor.data.TypeParameterInfo
import it.unibo.alchemist.boundary.dsl.processor.extensions.asString
import it.unibo.alchemist.boundary.dsl.processor.extensions.isInjectable
import it.unibo.alchemist.boundary.dsl.processor.extensions.nameOrTypeName
import it.unibo.alchemist.boundary.dsl.processor.extensions.typeName
import it.unibo.alchemist.core.Simulation
import it.unibo.alchemist.model.Environment
import it.unibo.alchemist.model.Incarnation
import it.unibo.alchemist.model.LinkingRule
import it.unibo.alchemist.model.Node
import it.unibo.alchemist.model.Reaction
import it.unibo.alchemist.model.TimeDistribution
import java.io.PrintWriter
import java.nio.charset.StandardCharsets
import parameterTypes

/** Symbol processor that emits DSL helpers for `@AlchemistKotlinDSL` classes. */
class DslBuilderProcessor(private val codeGenerator: CodeGenerator, private val logger: KSPLogger) : SymbolProcessor {

    /**
     * Processes every `@AlchemistKotlinDSL` symbol,
     * generating helpers and returning unresolved ones.
     */
    override fun process(resolver: Resolver): List<KSAnnotated> {
        context(resolver) {
            logger.dslInfo("Starting processing")
            val annotationName = AlchemistKotlinDSL::class.qualifiedName
            check(!annotationName.isNullOrBlank()) {
                "The Alchemist Kotlin DSL annotation name is invalid or missing: '$annotationName'"
            }
            logger.dslInfo("Alchemist DSL annotation: $annotationName")
            return resolver.getSymbolsWithAnnotation(annotationName)
                .fold(emptyList()) { invalidElements, symbol ->
                    when {
                        !symbol.validate() -> invalidElements + symbol
                        else -> {
                            if (symbol is KSClassDeclaration) {
                                processClass(symbol)
                            }
                            invalidElements
                        }
                    }
                }
        }
    }

    context(resolver: Resolver)
    private fun processClass(classDeclaration: KSClassDeclaration) {
        logger.dslInfo("Processing class ${classDeclaration.simpleName.asString()}")
        logger.dslInfo("Class qualified name: ${classDeclaration.qualifiedName?.asString()}")
        val injectableTypes = injectableTypes()
        val file = codeGenerator.createNewFile(
            dependencies = classDeclaration.containingFile
                ?.let { Dependencies(false, it) }
                ?: Dependencies.ALL_FILES,
            packageName = classDeclaration.packageName.asString(),
            fileName = "${classDeclaration.simpleName.asString()}Factory.kt",
        )
        val writer = PrintWriter(file, true, StandardCharsets.UTF_8)
        writer.println("// This file is generated by Alchemist DSL Processor. Do not edit manually.")
        writer.println()
        writer.println("package ${classDeclaration.packageName.asString()}")
        writer.println()
        val functionName = classDeclaration.simpleName.asString().replaceFirstChar { it.lowercaseChar() }
        classDeclaration.getConstructors()
            .filter { it.isPublic() }
            .mapNotNull { InjectableConstructor(it) }
            .forEach { (constructor, injectableParams, preservedParams) ->
                val context = injectableParams.joinToString(prefix = "context(", postfix = ")") { param ->
                    "${param.nameOrTypeName()}: ${param.type.asString()}"
                }
                writer.println(context)
                val typeParameters = constructor.typeParameters.takeIf { it.isNotEmpty() }
                    ?.joinToString(prefix = "<", postfix = "> ") {
                        buildString {
                            if (it.isReified) {
                                append("reified ")
                            }
                            append(it.name.asString())
                        }
                    }
                    .orEmpty()
                val parameters = preservedParams.joinToString(separator = NEWLINE_INDENT) { parameter ->
                    buildString {
                        if (parameter.isCrossInline) {
                            append("crossinline ")
                        }
                        if (parameter.isNoInline) {
                            append("noinline ")
                        }
                        if (parameter.isVararg) {
                            append("vararg ")
                        }
                        append(
                            "${parameter.name?.asString()}: ${parameter.type.asString()}",
                        )
                    }
                }
                val whereClause = constructor.typeParameters
                    .flatMap { typeParam ->
                        typeParam.bounds.map { bound ->
                            "${typeParam.simpleName.asString()} : ${bound.asString()}"
                        }
                    }
                    .takeIf { it.isNotEmpty() }
                    ?.joinToString(separator = NEWLINE_INDENT, prefix = "where\n    ", postfix = "\n")
                    .orEmpty()
                val arguments = constructor.parameters.joinToString(NEWLINE_INDENT) {
                    buildString {
                        if (it.isVararg) {
                            append("*")
                        }
                        append(it.nameOrTypeName())
                    }
                }
                writer.println(
                    """
                        |fun $typeParameters$functionName(
                        |    $parameters
                        |) $whereClause= ${classDeclaration.typeName}(
                        |    $arguments
                        |)
                    """.trimMargin(),
                )
            }
    }

    internal companion object {

        const val NEWLINE_INDENT = ",\n|    "

        private fun KSPLogger.dslInfo(message: String) = info("${DslBuilderProcessor::class.simpleName}: $message")

        context(resolver: Resolver)
        fun injectableTypes(): Set<KSType> = sequenceOf(
            resolver.getClassDeclarationByName<Environment<*, *>>(),
            resolver.getClassDeclarationByName<Incarnation<*, *>>(),
            resolver.getClassDeclarationByName<LinkingRule<*, *>>(),
            resolver.getClassDeclarationByName<Node<*>>(),
            resolver.getClassDeclarationByName<Reaction<*>>(),
            resolver.getClassDeclarationByName<Simulation<*, *>>(),
            resolver.getClassDeclarationByName<TimeDistribution<*>>(),
        )
            .map { checkNotNull(it).asStarProjectedType() }
            .toSet()
    }
}
