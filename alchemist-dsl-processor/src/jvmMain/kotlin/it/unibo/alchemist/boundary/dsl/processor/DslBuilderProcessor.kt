/*
 * Copyright (C) 2010-2025, Danilo Pianini and contributors
 * listed, for each module, in the respective subproject's build.gradle.kts file.
 *
 * This file is part of Alchemist, and is distributed under the terms of the
 * GNU General Public License, with a linking exception,
 * as described in the file LICENSE in the Alchemist distribution's top directory.
 */

package it.unibo.alchemist.boundary.dsl.processor

import com.google.devtools.ksp.getClassDeclarationByName
import com.google.devtools.ksp.getConstructors
import com.google.devtools.ksp.isPublic
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.validate
import injectableConstructors
import it.unibo.alchemist.boundary.dsl.AlchemistKotlinDSL
import it.unibo.alchemist.boundary.dsl.processor.extensions.asString
import it.unibo.alchemist.boundary.dsl.processor.extensions.nameOrTypeName
import it.unibo.alchemist.boundary.dsl.processor.extensions.typeName
import it.unibo.alchemist.core.Simulation
import it.unibo.alchemist.model.Environment
import it.unibo.alchemist.model.Incarnation
import it.unibo.alchemist.model.LinkingRule
import it.unibo.alchemist.model.Node
import it.unibo.alchemist.model.Reaction
import it.unibo.alchemist.model.TimeDistribution
import java.io.PrintWriter
import java.nio.charset.StandardCharsets
import org.apache.commons.math3.random.RandomGenerator

/** Symbol processor that emits DSL helpers for `@AlchemistKotlinDSL` classes. */
class DslBuilderProcessor(private val codeGenerator: CodeGenerator, private val logger: KSPLogger) : SymbolProcessor {

    /**
     * Processes every `@AlchemistKotlinDSL` symbol,
     * generating helpers and returning unresolved ones.
     */
    override fun process(resolver: Resolver): List<KSAnnotated> {
        context(resolver) {
            logger.dslInfo("Starting processing")
            val annotationName = AlchemistKotlinDSL::class.qualifiedName
            check(!annotationName.isNullOrBlank()) {
                "The Alchemist Kotlin DSL annotation name is invalid or missing: '$annotationName'"
            }
            logger.dslInfo("Alchemist DSL annotation: $annotationName")
            return resolver.getSymbolsWithAnnotation(annotationName)
                .fold(emptyList()) { invalidElements, symbol ->
                    when {
                        !symbol.validate() -> invalidElements + symbol
                        else -> {
                            if (symbol is KSClassDeclaration) {
                                processClass(symbol)
                            }
                            invalidElements
                        }
                    }
                }
        }
    }

    context(resolver: Resolver)
    private fun processClass(classDeclaration: KSClassDeclaration) {
        logger.dslInfo("Processing class ${classDeclaration.simpleName.asString()}")
        logger.dslInfo("Class qualified name: ${classDeclaration.qualifiedName?.asString()}")
        val file = codeGenerator.createNewFile(
            dependencies = classDeclaration.containingFile
                ?.let { Dependencies(false, it) }
                ?: Dependencies.ALL_FILES,
            packageName = classDeclaration.packageName.asString(),
            fileName = "${classDeclaration.simpleName.asString()}Factory.kt",
        )
        val writer = PrintWriter(file, true, StandardCharsets.UTF_8)
        writer.println("// This file is generated by the Alchemist DSL Processor. Do not edit manually.")
        writer.println()
        writer.println("package ${classDeclaration.packageName.asString()}")
        writer.println()
        val functionName = classDeclaration.simpleName.asString().replaceFirstChar { it.lowercaseChar() }
        val injectableConstructors = classDeclaration.getConstructors()
            .filter { it.isPublic() }
            .flatMap { it.injectableConstructors() }
            .toList()
        if (injectableConstructors.isEmpty()) {
            logger.warn(
                "No injectable constructors, ${AlchemistKotlinDSL::class.qualifiedName} will have no effect.",
                classDeclaration,
            )
        }
        injectableConstructors.forEach { (constructor, injectableParams, preservedParams) ->
            val context = injectableParams.joinToString(prefix = "context(", postfix = ")") { param ->
                "${param.nameOrTypeName()}: ${param.type.asString()}"
            }
            writer.println(context)
            val typeParameters = constructor.typeParameters.takeIf { it.isNotEmpty() }
                ?.joinToString(prefix = "<", postfix = "> ") { typeArgument ->
                    typeArgument.name.asString()
                }
                .orEmpty()
            val parameters = preservedParams.joinToString(separator = NEWLINE_INDENT) { parameter ->
                val vararg = if (parameter.isVararg) "vararg " else ""
                "$vararg${parameter.name?.asString()}: ${parameter.type.asString()}"
            }
            val whereClause = constructor.typeParameters
                .flatMap { typeParam ->
                    typeParam.bounds.map { bound ->
                        "${typeParam.simpleName.asString()} : ${bound.asString()}"
                    }
                }
                .takeIf { it.isNotEmpty() }
                ?.joinToString(separator = NEWLINE_INDENT, prefix = "where\n    ", postfix = "\n")
                .orEmpty()
            val useAllArguments = preservedParams.size + injectableParams.size == constructor.parameters.size
            val arguments = constructor.parameters.asSequence()
                .run {
                    when {
                        useAllArguments -> this
                        else -> {
                            val argumentsToUse = (preservedParams + injectableParams).toSet()
                            filter { it in argumentsToUse }
                        }
                    }
                }
                .joinToString(NEWLINE_INDENT) {
                    /*
                     * If it is a Java constructor, all arguments will be used.
                     * Since the same is true if there are no default parameters in Kotlin,
                     * it is safe to call positionally if `useAllArguments` is true.
                     * If it is a Kotlin constructor with default parameters, named arguments must be used to
                     * support cases in which there are mandatory parameters after the optional ones.
                     */
                    val name = it.name
                    when {
                        useAllArguments || name == null -> {
                            "${if (it.isVararg) "*" else ""}${it.nameOrTypeName()}"
                        }
                        else -> "${name.asString()} = ${it.nameOrTypeName()}"
                    }
                }
            writer.println(
                """
                    |fun $typeParameters$functionName(
                    |    $parameters
                    |) $whereClause= ${classDeclaration.typeName}(
                    |    $arguments
                    |)
                    |
                """.trimMargin(),
            )
        }
    }

    internal companion object {

        const val NEWLINE_INDENT = ",\n|    "

        private fun KSPLogger.dslInfo(message: String) = info("${DslBuilderProcessor::class.simpleName}: $message")

        context(resolver: Resolver)
        fun injectableTypes(): Set<KSType> = sequenceOf(
            resolver.getClassDeclarationByName<Environment<*, *>>(),
            resolver.getClassDeclarationByName<Incarnation<*, *>>(),
            resolver.getClassDeclarationByName<LinkingRule<*, *>>(),
            resolver.getClassDeclarationByName<Node<*>>(),
            resolver.getClassDeclarationByName<RandomGenerator>(),
            resolver.getClassDeclarationByName<Reaction<*>>(),
            resolver.getClassDeclarationByName<Simulation<*, *>>(),
            resolver.getClassDeclarationByName<TimeDistribution<*>>(),
        ).map { checkNotNull(it).asStarProjectedType() }.toSet()
    }
}
