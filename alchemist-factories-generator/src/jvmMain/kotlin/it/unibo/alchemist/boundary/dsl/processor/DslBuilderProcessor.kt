/*
 * Copyright (C) 2010-2026, Danilo Pianini and contributors
 * listed, for each module, in the respective subproject's build.gradle.kts file.
 *
 * This file is part of Alchemist, and is distributed under the terms of the
 * GNU General Public License, with a linking exception,
 * as described in the file LICENSE in the Alchemist distribution's top directory.
 */

package it.unibo.alchemist.boundary.dsl.processor

import com.google.devtools.ksp.getClassDeclarationByName
import com.google.devtools.ksp.getConstructors
import com.google.devtools.ksp.isAbstract
import com.google.devtools.ksp.isPublic
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSTypeParameter
import it.unibo.alchemist.boundary.dsl.processor.datatypes.InjectableConstructor
import it.unibo.alchemist.boundary.dsl.processor.extensions.asString
import it.unibo.alchemist.boundary.dsl.processor.extensions.injectableConstructors
import it.unibo.alchemist.boundary.dsl.processor.extensions.nameOrTypeName
import it.unibo.alchemist.core.Simulation
import it.unibo.alchemist.model.Environment
import it.unibo.alchemist.model.Incarnation
import it.unibo.alchemist.model.LinkingRule
import it.unibo.alchemist.model.Node
import it.unibo.alchemist.model.Reaction
import it.unibo.alchemist.model.TimeDistribution
import java.io.PrintWriter
import java.nio.charset.StandardCharsets
import org.apache.commons.math3.random.RandomGenerator

/** Symbol processor that emits DSL helpers for `@AlchemistKotlinDSL` classes. */
class DslBuilderProcessor(private val codeGenerator: CodeGenerator) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        context(resolver) {
            resolver.getNewFiles()
                .flatMap { it.declarations }
                .filterIsInstance<KSClassDeclaration>()
                .filter { it.isPublic() && !it.isAbstract() }
                .forEach { classDeclaration ->
                    val injectableConstructors = classDeclaration.getConstructors()
                        .flatMap { it.injectableConstructors() }
                        .toSet() // Remove duplicates
                    if (injectableConstructors.isNotEmpty()) {
                        val file = codeGenerator.createNewFile(
                            dependencies = classDeclaration.containingFile
                                ?.let { Dependencies(false, it) }
                                ?: Dependencies.ALL_FILES,
                            packageName = classDeclaration.packageName.asString(),
                            fileName = "${classDeclaration.simpleName.asString()}Factory.kt",
                        )
                        val writer = PrintWriter(file, true, StandardCharsets.UTF_8)
                        writer.println("// This file is generated by the Alchemist DSL Processor. Do not edit.\n")
                        writer.println("package ${classDeclaration.packageName.asString()}\n")
                        injectableConstructors.forEach { processConstructor(writer, classDeclaration, it) }
                    }
                }
        }
        return emptyList()
    }

    internal companion object {

        const val NEWLINE_INDENT = ",\n|    "

        context(resolver: Resolver)
        fun injectableTypes(): Set<KSType> = sequenceOf(
            resolver.getClassDeclarationByName<Environment<*, *>>(),
            resolver.getClassDeclarationByName<Incarnation<*, *>>(),
            resolver.getClassDeclarationByName<Node<*>>(),
            resolver.getClassDeclarationByName<RandomGenerator>(),
            resolver.getClassDeclarationByName<Reaction<*>>(),
            resolver.getClassDeclarationByName<Simulation<*, *>>(),
            resolver.getClassDeclarationByName<TimeDistribution<*>>(),
        ).map { checkNotNull(it).asStarProjectedType() }.toSet()

        private fun processConstructor(
            writer: PrintWriter,
            classDeclaration: KSClassDeclaration,
            injectableConstructor: InjectableConstructor,
        ) {
            val (constructor, injectableParams, preservedParams) = injectableConstructor
            val typeParameters = constructor.typeParameters.render()
            context(constructor.typeParameters.toSet()) {
                val parameters = preservedParams.joinToString(separator = NEWLINE_INDENT) { parameter ->
                    val vararg = if (parameter.isVararg) "vararg " else ""
                    "$vararg${parameter.name?.asString()}: ${parameter.type.asString()}"
                }
                val whereClause = constructor.typeParameters
                    .flatMap { typeParam ->
                        typeParam.bounds.map { bound ->
                            "${typeParam.simpleName.asString()} : ${bound.asString()}"
                        }
                    }
                    .takeIf { it.isNotEmpty() }
                    ?.joinToString(separator = NEWLINE_INDENT, prefix = "where\n    ", postfix = "\n")
                    .orEmpty()
                val useAllArguments = preservedParams.size + injectableParams.size == constructor.parameters.size
                val arguments = constructor.parameters.asSequence()
                    .run {
                        when {
                            useAllArguments -> this
                            else -> {
                                val argumentsToUse = (preservedParams + injectableParams).toSet()
                                filter { it in argumentsToUse }
                            }
                        }
                    }
                    .joinToString(NEWLINE_INDENT) {
                        /*
                         * If it is a Java constructor, all arguments will be used.
                         * Since the same is true if there are no default parameters in Kotlin,
                         * it is safe to call positionally if `useAllArguments` is true.
                         * If it is a Kotlin constructor with default parameters, named arguments must be used to
                         * support cases in which there are mandatory parameters after the optional ones.
                         */
                        val name = it.name
                        when {
                            useAllArguments || name == null -> {
                                "${if (it.isVararg) "*" else ""}${it.nameOrTypeName()}"
                            }
                            else -> "${name.asString()} = ${it.nameOrTypeName()}"
                        }
                    }
                val context = injectableParams.joinToString(prefix = "context(", postfix = ")") { param ->
                    "${param.nameOrTypeName()}: ${param.type.asString()}"
                }
                val classSimpleName = classDeclaration.simpleName.asString()
                val functionName = classSimpleName.replaceFirstChar { it.lowercaseChar() }
                val contextParameterNames = injectableParams.joinToString("") { param ->
                    param.nameOrTypeName().replaceFirstChar { it.uppercase() }
                }
                val argumentsString = if (parameters.isEmpty()) "()" else "(\n|    $parameters\n|)"
                writer.println(
                    """
                |/**
                | * Contextual builder for [$classSimpleName].
                | */
                |@JvmName("${functionName}WithContextual$contextParameterNames")
                |$context
                |fun $typeParameters$functionName$argumentsString $whereClause= ${classSimpleName}$typeParameters(
                |    $arguments
                |)
                |
                    """.trimMargin(),
                )
            }
        }

        private fun List<KSTypeParameter>.render() = takeIf { it.isNotEmpty() }
            ?.joinToString(prefix = "<", postfix = "> ") { typeArgument -> typeArgument.name.asString() }
            .orEmpty()
    }
}
