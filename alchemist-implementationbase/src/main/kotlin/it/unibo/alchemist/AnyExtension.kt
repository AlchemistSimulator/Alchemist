/*
 * Copyright (C) 2010-2019, Danilo Pianini and contributors listed in the main project's alchemist/build.gradle file.
 *
 * This file is part of Alchemist, and is distributed under the terms of the
 * GNU General Public License, with a linking exception,
 * as described in the file LICENSE in the Alchemist distribution's top directory.
 */
@file:JvmName("AnyExtension")
package it.unibo.alchemist

import it.unibo.alchemist.model.interfaces.Environment
import it.unibo.alchemist.model.interfaces.Position

/**
 * The opposite of [fold].
 *
 * @param extractor A function that provides a sequence of
 * elements given a specific element of the same type.
 * @receiver The starting element to unfold.
 * @return A sequence of [E] generated by unfolding on each
 * element provided by the [extractor] function.
 *
 * @See [fold].
 */
fun <E> E.unfold(extractor: (E) -> Sequence<E>): Sequence<E> =
    sequenceOf(this) + extractor(this).flatMap { it.unfold(extractor) }

/**
 * Tries to convert a concentration [T] into a valid position of type [P] descriptor.
 * Types are bound to the [environment] types.
 */
inline fun <T, reified P : Position<P>> T.toPosition(environment: Environment<T, P>): P = when (this) {
    is P -> this
    is Iterable<*> -> {
        val numbers = this.map {
            when (it) {
                is Number -> it
                else ->
                    throw IllegalStateException(
                        "The Iterable being converted to position must contain Numbers only" +
                            "but $it has type ${it?.javaClass ?: "null"}"
                    )
            }
        }
        environment.makePosition(*numbers.toTypedArray())
    }
    else ->
        throw IllegalArgumentException(
            "$this (type: ${if (this is Any) this.javaClass else null}) can't get converted to a Position"
        )
}
