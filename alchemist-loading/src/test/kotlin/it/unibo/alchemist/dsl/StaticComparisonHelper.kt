/*
 * Copyright (C) 2010-2025, Danilo Pianini and contributors
 * listed, for each module, in the respective subproject's build.gradle.kts file.
 *
 * This file is part of Alchemist, and is distributed under the terms of the
 * GNU General Public License, with a linking exception,
 * as described in the file LICENSE in the Alchemist distribution's top directory.
 */
package it.unibo.alchemist.dsl

import it.unibo.alchemist.boundary.Exporter
import it.unibo.alchemist.boundary.Loader
import it.unibo.alchemist.boundary.exporters.GlobalExporter
import it.unibo.alchemist.core.Simulation
import it.unibo.alchemist.model.Environment
import it.unibo.alchemist.model.Node
import it.unibo.alchemist.model.Position
import org.junit.jupiter.api.Assertions.assertEquals

/**
 * Helper for comparing static properties of DSL and YAML loaders
 *
 * This class focuses on comparing the initial state and configuration
 * of loaders without running the simulations.
 */
object StaticComparisonHelper {

    /**
     * Compares basic loader properties
     */
    fun compareBasicProperties(dslLoader: Loader, yamlLoader: Loader) {
        println("Comparing basic properties...")

        // Compare constants
        assertEquals(
            yamlLoader.constants,
            dslLoader.constants,
            "Constants should match",
        )

        // Compare variables by name, default value, and full stream
        val yamlVariables = yamlLoader.variables
        val dslVariables = dslLoader.variables
        assertEquals(
            yamlVariables.keys,
            dslVariables.keys,
            "Variable names should match",
        )
        yamlVariables.keys.forEach { name ->
            val yamlVar = yamlVariables.getValue(name)
            val dslVar = dslVariables.getValue(name)
            assertEquals(
                yamlVar.default,
                dslVar.default,
                "Default value of variable '$name' should match",
            )
            val yamlValues = yamlVar.stream().toList()
            val dslValues = dslVar.stream().toList()
            assertEquals(
                yamlValues,
                dslValues,
                "Values stream of variable '$name' should match",
            )
        }

        // Compare remote dependencies
        assertEquals(
            yamlLoader.remoteDependencies,
            dslLoader.remoteDependencies,
            "Remote dependencies should match",
        )

        // Compare launcher types (not exact instances)
        assertEquals(
            yamlLoader.launcher::class,
            dslLoader.launcher::class,
            "Launcher types should match",
        )
    }

    /**
     * Compares the simulations generated by both loaders
     */
    fun <T, P : Position<P>> compareSimulations(dslLoader: Loader, yamlLoader: Loader) {
        println("Comparing simulations...")

        val yamlSimulation = yamlLoader.getDefault<T, P>()
        val dslSimulation = dslLoader.getDefault<T, P>()

        // Compare environments
        compareEnvironments(dslSimulation.environment, yamlSimulation.environment)

        // Compare simulation properties
        compareSimulationProperties(dslSimulation, yamlSimulation)
    }

    /**
     * Compares two environments
     */
    private fun <T, P : Position<P>> compareEnvironments(dslEnv: Environment<T, P>, yamlEnv: Environment<T, P>) {
        println("Comparing environments...")

        // Compare node counts
        assertEquals(
            yamlEnv.nodes.size,
            dslEnv.nodes.size,
            "Node counts should match",
        )

        // Compare node positions
        val dslPositions = dslEnv.nodes.map { dslEnv.getPosition(it) }.toSet()
        val yamlPositions = yamlEnv.nodes.map { yamlEnv.getPosition(it) }.toSet()
        assertEquals(
            yamlPositions,
            dslPositions,
            "Node positions should match",
        )

        // Compare node contents (molecules and concentrations)
        compareNodeContents(dslEnv, yamlEnv)

        // Compare linking rules
        assertEquals(
            yamlEnv.linkingRule::class,
            dslEnv.linkingRule::class,
            "Linking rule types should match",
        )

        // Compare programs (reactions)
        comparePrograms(dslEnv, yamlEnv)

        // Compare layers
        compareLayers(dslEnv, yamlEnv)
    }

    /**
     * Compares node contents (molecules and concentrations)
     */
    private fun <T, P : Position<P>> compareNodeContents(dslEnv: Environment<T, P>, yamlEnv: Environment<T, P>) {
        println("Comparing node contents...")

        // Since we can't match by position, we'll compare all nodes by their contents
        val dslNodes = dslEnv.nodes.toList()
        val yamlNodes = yamlEnv.nodes.toList()

        // Compare total molecule counts
        val dslTotalMolecules = dslNodes.sumOf { it.moleculeCount }
        val yamlTotalMolecules = yamlNodes.sumOf { it.moleculeCount }

        assertEquals(
            yamlTotalMolecules,
            dslTotalMolecules,
            "Total molecule counts should match",
        )

        // Compare all node contents (without position matching)
        val dslContents = dslNodes.map { it.contents }.sortedBy { it.toString() }
        val yamlContents = yamlNodes.map { it.contents }.sortedBy { it.toString() }

        assertEquals(
            yamlContents,
            dslContents,
            "All node contents (molecules and concentrations) should match",
        )
    }

    /**
     * Compares programs between environments
     */
    private fun <T, P : Position<P>> comparePrograms(dslEnv: Environment<T, P>, yamlEnv: Environment<T, P>) {
        println("Comparing programs...")

        // Compare global reactions
        compareGlobalReactions(dslEnv, yamlEnv)

        // Compare node reactions
        compareNodeReactions(dslEnv, yamlEnv)
    }

    /**
     * Compares global reactions
     */
    private fun <T, P : Position<P>> compareGlobalReactions(dslEnv: Environment<T, P>, yamlEnv: Environment<T, P>) {
        println("Comparing global reactions...")

        val dslGlobalReactions = dslEnv.globalReactions.toList()
        val yamlGlobalReactions = yamlEnv.globalReactions.toList()

        assertEquals(
            yamlGlobalReactions.size,
            dslGlobalReactions.size,
            "Global reactions count should match",
        )

        // Compare global reaction types
        val dslGlobalTypes = dslGlobalReactions.map { it::class }.sortedBy { it.simpleName }
        val yamlGlobalTypes = yamlGlobalReactions.map { it::class }.sortedBy { it.simpleName }

        assertEquals(
            yamlGlobalTypes,
            dslGlobalTypes,
            "Global reaction types should match",
        )
    }

    /**
     * Compares node reactions (programs)
     */
    private fun <T, P : Position<P>> compareNodeReactions(dslEnv: Environment<T, P>, yamlEnv: Environment<T, P>) {
        println("Comparing node reactions...")

        val dslNodes = dslEnv.nodes.toList()
        val yamlNodes = yamlEnv.nodes.toList()

        // Compare total reaction counts
        val dslTotalReactions = dslNodes.sumOf { it.reactions.size }
        val yamlTotalReactions = yamlNodes.sumOf { it.reactions.size }

        assertEquals(
            yamlTotalReactions,
            dslTotalReactions,
            "Total node reactions count should match",
        )

        // Compare reaction types across all nodes
        val dslReactionTypes = dslNodes.flatMap { it.reactions }.map { it::class }.sortedBy { it.simpleName }
        val yamlReactionTypes = yamlNodes.flatMap { it.reactions }.map { it::class }.sortedBy { it.simpleName }

        assertEquals(
            yamlReactionTypes,
            dslReactionTypes,
            "Node reaction types should match",
        )

        // Compare reaction programs (conditions and actions)
        compareReactionPrograms(dslNodes, yamlNodes)
    }

    /**
     * Compares reaction programs by comparing their string representations and dependencies
     */
    private fun <T> compareReactionPrograms(dslNodes: List<Node<T>>, yamlNodes: List<Node<T>>) {
        println("Comparing reaction programs...")

        // Compare total reactions count
        val dslTotalReactions = dslNodes.sumOf { it.reactions.size }
        val yamlTotalReactions = yamlNodes.sumOf { it.reactions.size }

        assertEquals(
            yamlTotalReactions,
            dslTotalReactions,
            "Total reactions count should match",
        )

        // Compare reactions by their string representations and dependencies
        val dslReactions = dslNodes.flatMap { it.reactions }.map { reaction ->
            ReactionInfo(
                reactionString = try {
                    reaction.toString()
                } catch (e: Exception) {
                    "<error in toString()>"
                },
                inboundDependencies = reaction.inboundDependencies.map { it.toString() }.sorted(),
                outboundDependencies = reaction.outboundDependencies.map { it.toString() }.sorted(),
            )
        }.sortedBy { it.toString() }

        val yamlReactions = yamlNodes.flatMap { it.reactions }.map { reaction ->
            ReactionInfo(
                reactionString = try {
                    reaction.toString()
                } catch (e: Exception) {
                    "<error in toString()>"
                },
                inboundDependencies = reaction.inboundDependencies.map { it.toString() }.sorted(),
                outboundDependencies = reaction.outboundDependencies.map { it.toString() }.sorted(),
            )
        }.sortedBy { it.toString() }

        assertEquals(
            yamlReactions,
            dslReactions,
            "Reaction string representations and dependencies should match",
        )
    }

    /**
     * Data class to represent reaction information for comparison
     */
    private data class ReactionInfo(
        val reactionString: String,
        val inboundDependencies: List<String>,
        val outboundDependencies: List<String>,
    ) {
        override fun toString(): String =
            "Reaction(string='$reactionString', inbound=$inboundDependencies, outbound=$outboundDependencies)"
    }

    /**
     * Compares simulation properties
     */
    private fun compareSimulationProperties(dslSimulation: Simulation<*, *>, yamlSimulation: Simulation<*, *>) {
        println("Comparing simulation properties...")

        // Compare output monitors count
        assertEquals(
            yamlSimulation.outputMonitors.size,
            dslSimulation.outputMonitors.size,
            "Output monitors count should match",
        )

        // Compare output monitor types by class since instances may differ
        val yamlMonitorTypes = yamlSimulation.outputMonitors.map { it::class }
        val dslMonitorTypes = dslSimulation.outputMonitors.map { it::class }

        assertEquals(
            yamlMonitorTypes.sortedBy { it.simpleName },
            dslMonitorTypes.sortedBy { it.simpleName },
            "Output monitor types should match",
        )

        compareExporters(dslSimulation, yamlSimulation)
    }

    private fun compareExporters(dslSimulation: Simulation<*, *>, yamlSimulation: Simulation<*, *>) {
        val dslExporters = dslSimulation.outputMonitors
            .filterIsInstance<GlobalExporter<*, *>>()
            .flatMap { it.exporters }
        val yamlExporters = yamlSimulation.outputMonitors
            .filterIsInstance<GlobalExporter<*, *>>()
            .flatMap { it.exporters }

        assertEquals(
            yamlExporters.size,
            dslExporters.size,
            "Exporter counts should match",
        )

        val dslTypes = dslExporters.map { it::class }.sortedBy { it.simpleName }
        val yamlTypes = yamlExporters.map { it::class }.sortedBy { it.simpleName }
        assertEquals(
            yamlTypes,
            dslTypes,
            "Exporter types should match",
        )

        compareDataExtractors(dslExporters, yamlExporters)
    }

    private fun compareDataExtractors(dslExporters: List<Exporter<*, *>>, yamlExporters: List<Exporter<*, *>>) {
        val dslTotal = dslExporters.sumOf { it.dataExtractors.size }
        val yamlTotal = yamlExporters.sumOf { it.dataExtractors.size }
        assertEquals(
            yamlTotal,
            dslTotal,
            "Total data extractor counts should match",
        )

        val dslTypes = dslExporters.flatMap { it.dataExtractors }.map { it::class }.sortedBy { it.simpleName }
        val yamlTypes = yamlExporters.flatMap { it.dataExtractors }.map { it::class }.sortedBy { it.simpleName }
        assertEquals(
            yamlTypes,
            dslTypes,
            "Data extractor types should match",
        )

        val dslInfo = dslExporters.flatMap { it.dataExtractors }.map { extractor ->
            ExtractorInfo(
                type = extractor::class.simpleName.orEmpty(),
                columns = extractor.columnNames.sorted(),
            )
        }.sortedBy { it.toString() }
        val yamlInfo = yamlExporters.flatMap { it.dataExtractors }.map { extractor ->
            ExtractorInfo(
                type = extractor::class.simpleName.orEmpty(),
                columns = extractor.columnNames.sorted(),
            )
        }.sortedBy { it.toString() }
        assertEquals(
            yamlInfo,
            dslInfo,
            "Data extractor information (types and column names) should match",
        )
    }

    private data class ExtractorInfo(
        val type: String,
        val columns: List<String>,
    ) {
        override fun toString(): String = "Extractor(type=$type, columns=$columns)"
    }

    /**
     * Compares layers between environments
     */
    private fun <T, P : Position<P>> compareLayers(dslEnv: Environment<T, P>, yamlEnv: Environment<T, P>) {
        println("Comparing layers...")

        // Simplified check
        // If two layers have different molecules this test does not detect it.

        // Compare layer counts
        assertEquals(
            yamlEnv.layers.size,
            dslEnv.layers.size,
            "Layer counts should match",
        )

        // Compare layer types
        val dslLayerTypes = dslEnv.layers.map { it::class }.sortedBy { it.simpleName }
        val yamlLayerTypes = yamlEnv.layers.map { it::class }.sortedBy { it.simpleName }

        assertEquals(
            yamlLayerTypes,
            dslLayerTypes,
            "Layer types should match",
        )

        // Compare layer values at sample positions
        compareLayerValues(dslEnv, yamlEnv)
    }

    /**
     * Compares layer values at sample positions
     */
    private fun <T, P : Position<P>> compareLayerValues(dslEnv: Environment<T, P>, yamlEnv: Environment<T, P>) {
        println("Comparing layer values...")

        // Sample positions to test layer values
        val samplePositions = mutableListOf<P>()

        // Add positions from both environments' nodes
        samplePositions.addAll(dslEnv.nodes.map { dslEnv.getPosition(it) })
        samplePositions.addAll(yamlEnv.nodes.map { yamlEnv.getPosition(it) })

        // Remove duplicates
        val uniquePositions = samplePositions.distinct()

        if (uniquePositions.isNotEmpty()) {
            for (position in uniquePositions) {
                val dslLayerValues = dslEnv.layers.map { (it.getValue(position)) }
                val yamlLayerValues = yamlEnv.layers.map { it.getValue(position) }
                // Convert all values to Double for comparison to handle Int vs Double differences
                val dslDoubleValues = dslLayerValues.map { value ->
                    when (value) {
                        is Number -> value.toDouble()
                        else -> value.toString().toDoubleOrNull() ?: 0.0
                    }
                }
                val yamlDoubleValues = yamlLayerValues.map { value ->
                    when (value) {
                        is Number -> value.toDouble()
                        else -> value.toString().toDoubleOrNull() ?: 0.0
                    }
                }

                assertEquals(
                    dslDoubleValues,
                    yamlDoubleValues,
                    "Layer values at position $position should match",
                )
            }
        } else {
            println("Skipping layer value comparison - no valid positions found")
        }
    }
}
