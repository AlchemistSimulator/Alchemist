module attraction_repulsion
import protelis:coord:spreading
import protelis:coord:accumulation
import it.unibo.alchemist.model.smartcam.ProtelisUtils.averageOfTuple
import utils

def targetsPositions(targets) {
    targets.map((t) -> {t.getPosition()})
}

def distanceToPosition(pos) {
    euclideanDistance(self.getCoordinates(), pos)
}

def positionsToDirections(positions) {
    positions.map((p) -> {p - self.getCoordinates()})
}

def distances(positions) {
    positions.map((p) -> {distanceToPosition(p)})
}

def targetForce(position) {
    let distance = distanceToPosition(position);
    if(distance < 15){
        15 - distance
    } else {
        min(-2, 15 - distance)
    }
}

def targetsForces(targets) {
    targetsPositions(targets)
        .map((t) -> {targetForce(t)})
}

def cameraForce(position) {
    10 / max(1, distanceToPosition(position) ^ 2)
}

def camerasForces(cameras) {
    cameras.map((c) -> {cameraForce(c)})
}

def unitVector(v) {
    let m = sqrt(v.get(0)^2 + v.get(1)^2);
    if(m > 0){
        [v.get(0) / m, v.get(1) / m]
    } else {
        v
    }
}

def restrict(value, range) {
    max(range.get(0), min(range.get(1), value))
}




def explore(cameraPositions) {
    env.put("state", "exploring");
    
    noTarget()
}


rep(myTarget <- noTarget()){
    let myPos = self.getCoordinates();
    let cameraPositions = nbr(myPos);

    if(myTarget == noTarget()){
        explore(cameraPositions)
    } else {
        noTarget()
    }
}




/*
// ORIGINALEE
env.put("state", "following");
let mypos = self.getCoordinates();
let distances = self.nbrRange();
env.putField("distances", distances);
let positions = self.nbrVector();
positions = [positions.get(0), positions.get(1)];
env.putField("positions", positions);
let repulsion = 30 / distances ^ 2;
env.putField("repulsion", repulsion);
let directedForces = positions * repulsion;
env.putField("directedForces", directedForces);
let finalRepulsion = meanHood(directedForces);
env.put("finalRepulsion", finalRepulsion);

let targets = nbr(getVision());
env.putField("targets",targets);
let allTargets = unionHood PlusSelf(targets).map((t) -> {t.getPosition()})
distances = allTargets.map((t) -> {distanceToPosition(t)})
let sumForces = [0, 0]
directedForces = allTargets.map((t) -> {
    let dist = distanceToPosition(t);
    let attraction = if(dist > 15){
        30 / dist
    } else {
        0
    }
    let f = unitVector(t - mypos);
    let fx = f.get(0) * attraction;
    let fy = f.get(1) * attraction;
    sumForces = [sumForces.get(0) + fx, sumForces.get(1) + fy];
    [fx, fy]
});
env.put("forceToTargets", directedForces);
let finalAttraction = if(directedForces.size() > 0) {
    [sumForces.get(0) / directedForces.size(), sumForces.get(1) / directedForces.size()];
} else {
    [0, 0]
};
env.put("finalAttraction", finalAttraction);
let finalForce = finalRepulsion + finalAttraction;
env.put("finalForce", finalForce);

let desiredPosition = [mypos.get(0), mypos.get(1)] + finalForce;
env.put("destination", desiredPosition);

let closestTarget = env.get("vision").map((t) -> {t.getPosition()}).reduce(desiredPosition, (t1, t2) -> {minBy(t1, t2, distanceToPosition)});
env.put("heading", closestTarget);
0
// FINEE
*/



/*
let myPos = self.getCoordinates();
let targets = unionHood PlusSelf(nbr(env.get("vision")));
let cameras = unionHood(nbr(myPos));
let force = averageOfTuple(targetsForces(targets).mergeAfter(camerasForces(cameras)));
env.put("force", force);
env.put("destination", myPos + force);
let closestTarget = targets.reduce([], (t1, t2) -> {min(distanceToPosition(t1), distanceToPosition(t2))});
env.put("heading", closestTarget);
0
*/