/* Based on "Online Multi-object k-coverage with Mobile Smart Cameras" by Lukas Esterle and Peter Lewis.
 * Replicates the BC-RE algorithm, aka Broadcast-Received calls.
 * Each camera broadcasts requests for each target and provisions the one with the least requests in case it is not already
 * following a target.
 *
 * In case there are multiple targets with the least requests number, then the closest one is chosen.
 * (This may differ from Esterle's algorithm: it is unspecified although it seems reasonable)
 */

module bc_re
import protelis:lang:utils
import protelis:coord:spreading
import protelis:coord:accumulation
import it.unibo.alchemist.model.smartcam.ProtelisUtils.elementsWithLeastSources
import utils



def explore() {
    env.put("state", "exploring");
    noTarget()
}

def follow(target) {
    env.put("state", "following");
    env.put("destination", target.getPosition());
    env.put("heading", target.getPosition());
    target
}

def distanceFromTarget(target) {
    euclideanDistance(self.getCoordinates(), target.getPosition())
}

def closestTarget(targets) {
    targets.reduce(noTarget(), (t1, t2) -> { minBy(t1, t2, distanceFromTarget) })
}



rep(myTarget <- noTarget()) {
    let localTargets = getVision();
    let allTargets = nbr(localTargets);
    let possibleTarget = closestTarget(elementsWithLeastSources(allTargets));
    myTarget = if(myTarget == noTarget() || !localTargets.contains(myTarget)) {
        possibleTarget
    } else {
        localTargets.get(localTargets.indexof(myTarget)) // updated position
    };
    if(myTarget == noTarget()) {
        explore()
    } else {
        follow(myTarget)
    }
}