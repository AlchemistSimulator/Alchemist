module program1
import protelis:lang:utils
import protelis:coord:spreading
import protelis:coord:accumulation
import java.lang.System.out
import java.lang.Math.sqrt

public def log(msg) {
    out.println(msg);
    0
}

def noTarget() {0}

def follow(target) {
    env.put("destination", target.getPosition());
    target
}


def distanceToTarget(target) {
    let other = target.getPosition();
    let me = self.getCoordinates();
    let diffX = other.getX() - me.get(0);
    let diffY = other.getY() - me.get(1);
    sqrt(diffX*diffX + diffY*diffY)
}

def minBy(a, b, getValue) {
    if(getValue.apply(a) < getValue.apply(b)){
        a
    } else {
        b
    }
}

def chooseTarget(targets, currentTarget) {
    targets.reduce(noTarget(), (a,b) -> {minBy(a,b,distanceToTarget)})
}


/*
rep(target <- 0) {
    let targets = env.get("vision");
    if(targets.size() > 0) {
        follow(chooseTarget(targets, target))
    } else {
        0
    }
}
*/

rep(target <- noTarget()) {
    let localTargets = env.get("vision");
    let targets = unionHood(nbr(localTargets));
    env.put("targets", targets);
    let myTarget = chooseTarget(targets, target);
    if(myTarget != noTarget()) {
        /*
        let myChoice = [myTarget, [[self.getUID(), distanceToTarget(myTarget)]]]
        let chosenTargets = nbr(myChoice);
        chosenTargets = hood((a,b) -> {
            if(a.indexof(
        }, myChoice, chosenTargets)
        env.putField("chosenTargets", chosenTargets);
        chosenTargets.coupleIterator().forEach(pair -> {
            env.put("pair", pair)
        });
        */
        follow(myTarget)
    } else { myTarget };
    env.put("TARGET", myTarget);
    myTarget
}
