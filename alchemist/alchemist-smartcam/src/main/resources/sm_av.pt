/* Based on "Online Multi-object k-coverage with Mobile Smart Cameras" by Lukas Esterle and Peter Lewis.
 * Replicates the SM-AV algorithm, aka k-SMOOTH-Available.
 */


module sm_av
import protelis:coord:spreading
import protelis:coord:accumulation
import it.unibo.alchemist.model.smartcam.ProtelisUtils.buildOverlapRelationsGraph
import it.unibo.alchemist.model.smartcam.ProtelisUtils.findDevicesByData
import it.unibo.alchemist.model.smartcam.ProtelisUtils.cloneFieldToMap
import it.unibo.alchemist.model.smartcam.ProtelisUtils.getDataByDevice
import utils


rep(info <- [noTarget(), buildOverlapRelationsGraph(1, 0.995, 0.95)]){
    let myTarget = info.get(0);
    let graph = info.get(1);
    let localObjects = getVision();
    let globalObjects = cloneFieldToMap(nbr(localObjects));
    graph.evaporate();
    graph.update(globalObjects);

    let devicesToNotify = graph.smooth();
    //env.put("devicesToNotify", devicesToNotify);
    let notifiedDevices = nbr(devicesToNotify);
    env.putField("notifiedDevices", notifiedDevices);
    let notifiers = findDevicesByData(notifiedDevices) {
        it.contains(self.getDeviceUID())
    }
    //env.put("notifiers", notifiers);
    // now filter targets by who really notified me
    let allTargets = notifiers
        .map { id -> onlyTargets(globalObjects.get(id)) }
        .reduce([]) { d1, d2 -> d1.union(d2) }
        .union(onlyTargets(localObjects));
    //env.put("allTargets", allTargets);

    myTarget = if(myTarget == noTarget() || !allTargets.contains(myTarget)) {
        closestTarget(allTargets)
    } else {
        allTargets.get(allTargets.indexof(myTarget)) // updated position
    };
    //env.put("myTarget", myTarget);
    followOrExplore(myTarget);
    [myTarget, graph]
}
